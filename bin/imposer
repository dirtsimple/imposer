#!/usr/bin/env bash
# ---
# This file is automatically generated from imposer.md - DO NOT EDIT
# ---

# MIT License
#
# Copyright (c) 2017 PJ Eby
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

mdsh_raw_bash_runtime+=($'#!/usr/bin/env bash\n\n# --- BEGIN jqmd runtime ---\n')
mdsh_raw_bash_runtime+=($'jqmd_imports=\njqmd_filters=\njqmd_defines=\n\nHAVE_FILTERS() { [[ ${jqmd_filters-} ]]; }\nCLEAR_FILTERS() { unset jqmd_filters; }\n\nIMPORTS() { jqmd_imports+="${jqmd_imports:+$\'\\n\'}$1"; }\nDEFINE()  { jqmd_defines+="${jqmd_defines:+$\'\\n\'}$1"; }\nFILTER()  { jqmd_filters+="${jqmd_filters:+|}$1"; }\n')
mdsh_raw_bash_runtime+=($'JQOPTS=(jq)\nJQ_OPTS() { JQOPTS+=("$@"); }\nARG()     { JQ_OPTS --arg     "$1" "$2"; }\nARGJSON() { JQ_OPTS --argjson "$1" "$2"; }\n')
mdsh_raw_bash_runtime+=($'RUN_JQ() {\n    local opt nargs cmd=(jq); set -- "${JQOPTS[@]:1}" "$@"\n\n    while (($#)); do\n        case "$1" in\n        -{f,-fromfile})                     nargs=2 ; FILTER "$(<"$2")" ;;\n        -{L,-indent})                       nargs=2 ;;\n        --{arg,arjgson,slurpfile,argfile})  nargs=3 ;;\n        --)  break   ;; # rest of args are data files\n        -*)  nargs=1 ;;\n        *)   FILTER "$1"; break ;; # jq program: data files follow\n        esac\n        cmd+=("${@:1:$nargs}")    # add $nargs args to cmd\n        shift $nargs\n    done\n\n    HAVE_FILTERS || FILTER .    # jq needs at least one filter expression\n\n    "${cmd[@]}" -f <(\n        printf "%s\\n" "${jqmd_imports-}" "${jqmd_defines-}" "${jqmd_filters-}"\n    ) "${@:2}"\n\n    CLEAR_FILTERS   # cleanup for any re-runs\n}\n')
mdsh_raw_bash_runtime+=($'jqmd_data=jqmd::data\n@data() { jqmd_data="${1-}"; }\n\nYAML()  { y2j "$1"; JSON "$REPLY"; }\nJSON()  { FILTER "$jqmd_data($1)"; }\n')
mdsh_raw_bash_runtime+=($'DEFINE \'\ndef jqmd::blend($other; combine): . as $this | . *  $other | . as $combined | with_entries(\n  if (.key | in($this)) and (.key | in($other)) then\n    .this = $this[.key] | .other = $other[.key] | combine\n  else . end\n);\n\ndef jqmd::combine: (.this|type) as $this | (.other|type) as $other | .value =\n  if $this == "array" then\n    if $other == "array" then .this + .other else .this + [.other] end\n  elif $this == "object" then\n    if $other == "object" then\n      .other as $o | (.this | jqmd::blend($o; jqmd::combine))\n    else .other end\n  else .other end;  # everything else just overrides\n\ndef jqmd::data($data): {this: ., other:$data} | jqmd::combine | .value ;\n\'\n')
mdsh_raw_bash_runtime+=($'y2j() {\n    local p j="$(echo "$1" | yaml2json)"; REPLY=\n    while [[ $j == *\'\\\\(\'* ]]; do\n        p=${j%%\'\\\\(\'*}; j=${j#"$p"\'\\\\(\'}\n        if [[ $p =~ (^|[^\\\\])(\'\\\\\\\\\')*$ ]]; then\n            p="${p}"\'\\(\' # odd, unbalance the backslash\n        else\n            p="${p}("   # even, remove one actual backslash\n        fi\n        REPLY+=$p\n    done\n    REPLY+=$j\n}\n')
mdsh_raw_bash_runtime+=($'yaml2json:cmd() { command yaml2json /dev/stdin; }\n\nyaml2json:py() {\n    python -c \'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout)\'\n}\n\nyaml2json:php() {\n    php -r \'echo json_encode( yaml_parse(file_get_contents("php://stdin")) );\'\n}\n\nyaml2json() {\n    local kind  # auto-select between available yaml2json implementations\n    for kind in cmd py php; do\n        REPLY=($(yaml2json:$kind < <(echo "a: b") 2>/dev/null || true))\n        printf -v REPLY %s ${REPLY+"${REPLY[@]}"}\n        if [[ "$REPLY" == \'{"a":"b"}\' ]]; then\n            eval "yaml2json() { yaml2json:$kind; }"; yaml2json; return\n        fi\n    done\n    mdsh-error "To process YAML, must have one of: yaml2json, PyYAML, or php w/yaml extension"\n    exit 69 # EX_UNAVAILABLE\n}\n\n# --- END jqmd runtime ---\n')
# Language Support
mdsh-compile-jq()         { printf 'FILTER  %q\n' "$1"; }
mdsh-compile-jq_defs()    { printf 'DEFINE  %q\n' "$1"; }
mdsh-compile-jq_imports() { printf 'IMPORTS %q\n' "$1"; }

mdsh-compile-yml()  { y2j "$1"; mdsh-compile-json "$REPLY"; }
mdsh-compile-yaml() { y2j "$1"; mdsh-compile-json "$REPLY"; }
mdsh-compile-json() { mdsh-compile-jq "$jqmd_data($1)"; }

const() {
    case "${tag_words-}" in
    yaml|yml) y2j "$block"; printf "DEFINE %q\n" "def $1: $REPLY ;" ;;
    json)     printf "DEFINE %q\n" "def $1: $block ;" ;;
    *) mdsh-error "Invalid language for constant: '%s'" "${tag_words-}"
    esac
}
# Load the runtime so it's usable by mdsh
printf -v REPLY '%s\n' "${mdsh_raw_bash_runtime[@]}"; eval "$REPLY"

# Add runtime to the top of compiled scripts
printf -v REPLY 'mdsh:file-header() { echo -n %q; }' "$REPLY"; eval "$REPLY"

# Ensure scripts process any leftover filters at end
mdsh:file-footer() { echo 'if [[ $0 == ${BASH_SOURCE-} ]] && HAVE_FILTERS; then RUN_JQ; fi'; }
mdsh.--no-runtime() ( unset -f mdsh:file-header mdsh:file-footer; mdsh-main "$@"; )
mdsh.--yaml() (
    fn-exists "yaml2json:${1-}" || mdsh-error "No such yaml2json processor: ${1-}" || exit $?
    eval 'yaml2json() { yaml2json:'"$1"'; }'
    mdsh-main "${@:2}"
)

mdsh.-R() { mdsh.--no-runtime "$@"; }
mdsh.-y() { mdsh.--yaml "$@"; }
set -euo pipefail  # Strict mode
mdsh-parse() {
	local cmd=$1 lang block ln indent fence close_fence indent_remove
	local open_fence='^( {0,3})(~~~+|```+) *([^`]*)$'
	while IFS= read -r ln; do
		if [[ $ln =~ $open_fence ]]; then
			indent=${BASH_REMATCH[1]} fence=${BASH_REMATCH[2]} lang=${BASH_REMATCH[3]} block=
			close_fence="^( {0,3})$fence+ *\$" indent_remove="^${indent// / ?}"
			while IFS= read -r ln && ! [[ $ln =~ $close_fence ]]; do
				! [[ $ln =~ $indent_remove ]] || ln=${ln#$BASH_REMATCH}; block+=$ln$'\n'
			done
			lang="${lang%"${lang##*[![:space:]]}"}"; $cmd fenced "$lang" "$block";
		fi
	done
}
mdsh-source() {
	local MDSH_FOOTER= MDSH_SOURCE
	if [[ ${1:--} != '-' ]]; then
		MDSH_SOURCE="$1"
		mdsh-parse __COMPILE__ <"$1"
	else mdsh-parse __COMPILE__
	fi
	${MDSH_FOOTER:+ printf %s "$MDSH_FOOTER"}; MDSH_FOOTER=
}
mdsh-compile() (  # <-- force subshell to prevent escape of compile-time state
	mdsh-source "$@"
)
__COMPILE__() {
	[[ $1 == fenced && $fence == '```' && ! $indent ]] || return 0  # only unindented ``` code
	local lang="${2//[^_[:alnum:]]/_}"; # convert language to safe variable/function name
	local tag_words=($2);  # check for command blocks first
	if [[ ${tag_words[1]-} == '!'* ]]; then
		set -- "$3" "$2"; eval "${2#*!}"; return
	elif [[ ${tag_words[1]-} == '|'* ]]; then
		echo "${2#*|} <<'\`\`\`'"; printf '%s```\n' "$3"; return
	elif fn-exists mdsh-lang-$lang; then
		mdsh-rewrite mdsh-lang-$lang "{" "} <<'\`\`\`'"; printf '%s```\n' "$3"
	elif fn-exists mdsh-compile-$lang; then
		mdsh-compile-$lang "$3"
	else
		mdsh-misc "$2" "$3"
	fi

	if fn-exists mdsh-after-$lang; then
		mdsh-rewrite mdsh-after-$lang
	fi
}
# fn-exists: succeed if argument is a function
fn-exists() { declare -F -- "$1"; } >/dev/null
# Output body of func $1, optionally replacing the opening/closing { and } with $2 and $3
mdsh-rewrite() {
	declare -f $1 | sed -e '1d; 2s/^{ $/'"${2-"{"}"'/; $s/^}$/'"${3-"\}"}"'/'
}
mdsh-misc()          { mdsh-data "$@"; }    # Treat unknown languages as data
mdsh-compile-()      { :; }                 # Ignore language-less blocks

mdsh-compile-mdsh()  { eval "$1"; }         # Execute `mdsh` blocks in-line
mdsh-compile-mdsh_main() { [[ $MDSH_MODULE ]] || eval "$1"; }

mdsh-compile-shell() { printf '%s' "$1"; }  # Copy `shell` blocks to the output
mdsh-compile-shell_main() { [[ $MDSH_MODULE ]] || printf '%s' "$1"; }
mdsh-data() {
	printf "mdsh_raw_${1//[^_[:alnum:]]/_}+=(%q)\n" "$2"
}
mdsh-compile-shell_mdsh() {
	indent= fence='```' __COMPILE__ fenced mdsh "$1"
}
mdsh-compile-shell_mdsh_main() {
	indent= fence='```' __COMPILE__ fenced "mdsh main" "$1"
}
# Main program: check for arguments and run markdown script
mdsh-main() {
	(($#)) || mdsh-error "Usage: %s [--out FILE] [ --compile | --eval ] markdownfile [args...]" "${0##*/}"
	case "$1" in
	--) mdsh-interpret "${@:2}" ;;
	--*|-?) fn-exists "mdsh.$1" || mdsh-error "%s: unrecognized option: %s" "${0##*/}" "$1"
		"mdsh.$1" "${@:2}"
		;;
	-??*) mdsh-main "${1::2}" "-${1:2}" "${@:2}" ;;  # split '-abc' into '-a -bc' and recurse
	*)  mdsh-interpret "$@" ;;
	esac
}
# Run markdown file as main program, with $0 == $BASH_SOURCE == "" and
# MDSH_ZERO pointing to the original $0.

function mdsh-interpret() {
	printf -v cmd 'eval "$(%q --compile %q)"' "$0" "$1"
	MDSH_ZERO="$1" exec bash -c "$cmd" "" "${@:2}"
}
mdsh.--compile() {
	(($#)) || mdsh-error "Usage: %s --compile FILENAME..." "${0##*/}"
	! fn-exists mdsh:file-header || mdsh:file-header
	for REPLY; do mdsh-compile "$REPLY"; done
	! fn-exists mdsh:file-footer || mdsh:file-footer
}

mdsh.-c() { mdsh.--compile "$@"; }
mdsh.--eval() {
	(($# == 1)) && [[ $1 != - ]] ||
		mdsh-error "Usage: %s --eval FILENAME" "${0##*/}"
	mdsh.--compile "$1"
	echo $'__status=$? eval \'return $__status || exit $__status\' 2>/dev/null'
}

mdsh.-E() { mdsh.--eval "$@"; }
mdsh.--out() {
	if REPLY=("$(mdsh-main "${@:2}")"); then
		exec echo "$REPLY" >"$1"   # handle self-compiling properly
	else exit $?;
	fi
}

mdsh.-o() { mdsh.--out "$@"; }
# mdsh-error: printf args to stderr and exit w/EX_USAGE (code 64)
mdsh-error() { printf "$1\n" "${@:2}" >&2; exit 64; }
mdsh.--help() {
	printf "Usage: %s [--out FILE] [ --compile | --eval ] markdownfile [args...]\n" "${0##*/}"
	echo -e '
Run and/or compile code blocks from markdownfile(s) to bash.
Use a filename of `-` to run or compile from stdin.

Options:
  -h, --help                Show this help message and exit
  -c, --compile MDFILE...   Compile MDFILE(s) to bash and output on stdout.
  -E, --eval MDFILE         Compile one file w/a shelldown-support footer line\n'
}

mdsh.-h() { mdsh.--help "$@"; }
MDSH_LOADED_MODULES=
MDSH_MODULE=

@import() {
	if ! [[ $MDSH_LOADED_MODULES == *"<$1>"* ]]; then
		MDSH_LOADED_MODULES+="<$1>"; local MDSH_MODULE=$1
		"${@:2}"
	fi
}
@module() {
	! [[ $MDSH_MODULE ]] || return 0
	set -- "${1:-${MDSH_SOURCE-}}"
	echo "#!/usr/bin/env bash"
	echo "# ---"
	echo "# This file is automatically generated from ${1##*/} - DO NOT EDIT"
	echo "# ---"
	echo
}
@main() {
	! [[ $MDSH_MODULE ]] || return 0
	MDSH_FOOTER=$'if [[ $0 == "${BASH_SOURCE-}" ]]; then '"$1"$' "$@"; fi\n'
}
@comment() (  # subshell for cd
	! [[ "${MDSH_SOURCE-}" == */* ]] || cd "${MDSH_SOURCE%/*}"
	sed -e 's/^\(.\)/# \1/; s/^$/#/;' "$@"
	echo
)
mdsh-embed() {
	local f=$1 base=${1##*/}; local boundary="# --- EOF $base ---" contents ctr=
	[[ $f == */* && -f $f ]] || f=$(command -v "$f") || {
		echo "Can't find module $1" >&2; return 69  # EX_UNAVAILABLE
	}
	contents=$'\n'$(<"$f")$'\n'
	while [[ $contents == *$'\n'"$boundary"$'\n'* ]]; do
		let ctr++; boundary="# --- EOF $base.$ctr ---"
	done
	printf $'{ if [[ $OSTYPE != cygwin && $OSTYPE != msys && -e /dev/fd/0 ]]; then source /dev/fd/0; else source <(cat); fi; } <<\'%s\'%s%s\n' "$boundary" "$contents" "$boundary"
}
fstamp() {
	if ! stat -c %y "$1" 2>/dev/null; then
		fstamp() { stat -f %m "$1"; }
		fstamp "$1";
	fi
} 2>/dev/null

mdsh-make() {
	[[ -f "$1" && -f "$2" && "$(fstamp "$1")" == "$(fstamp "$2")" ]] || {
		( "${@:3}" && mdsh-main --out "$2" --compile "$1" ) && touch -r "$1" "$2"
	}
}
mdsh-cache() {
	[[ -d "$1" ]] || mkdir -p "$1"
	flatname "${3:-$2}"; REPLY="$1/$REPLY"; mdsh-make "$2" "$REPLY" "${@:4}"
}

flatname() {
	REPLY="${1//\%/%25}"; REPLY="${REPLY//\//%2F}"; REPLY="${REPLY/#./%2E}"
	REPLY="${REPLY//\\/%5C}"
}
# run-markdown file args...
# Compile `file` and source the result, passing along any positional arguments
run-markdown() {
	if [[ $BASH_VERSINFO == 3 ]]; then # bash 3 can't source from proc
		source /dev/fd/0 "${@:2}" <<<"$(mdsh-source "${1--}")"
	else source <(mdsh-source "${1--}") "${@:2}"
	fi
}
#!/usr/bin/env bash

realpath.location() { realpath.follow "$1"; realpath.absolute "$REPLY" ".."; }
realpath.resolved() { realpath.follow "$1"; realpath.absolute "$REPLY"; }
realpath.dirname()  { if [[ $1 =~ /+[^/]+/*$ ]]; then REPLY="${1%${BASH_REMATCH}}"; REPLY=${REPLY:-/}; else REPLY=.; fi }
realpath.basename() { if [[ $1 =~ /*([^/]+)/*$ ]]; then REPLY="${BASH_REMATCH[1]}"; else REPLY=/; fi }

realpath.follow() {
    local target
    while [[ -L "$1" ]] && target=$(readlink -- "$1"); do
        realpath.dirname "$1"
        # Resolve symlink target relative to symlink's directory
        [[ $REPLY != . && $target != /* ]] && REPLY=$REPLY/$target || REPLY=$target
        # Break out if we found a symlink loop
        for target; do [[ $REPLY == "$target" ]] && break 2; done
        # Add current result to the loop-detect list and tail-recurse
        set -- "$REPLY" "$@"
    done
    REPLY="$1"
}

realpath.absolute() {
    REPLY=$PWD; local no_eg; shopt -q extglob || { no_eg=y; shopt -s extglob; }
    while (($#)); do case $1 in
        /*) REPLY=/; set -- "${1##+(/)}" "${@:2}" ;;
        */*) set -- "${1%%/*}" "${1##${1%%/*}+(/)}" "${@:2}" ;;
        ''|.) shift ;;
        ..) realpath.dirname "$REPLY"; shift ;;
        *) REPLY="${REPLY%/}/$1"; shift ;;
    esac; done; ${no_eg:+shopt -u extglob}
}

realpath.canonical() {
    local target=""
    realpath.follow "$1"; set -- "$REPLY"   # $1 is now resolved
    realpath.basename "$1"; target=$REPLY   # target = basename $1
    realpath.dirname "$1";
    [[ $REPLY != "$1" ]] && realpath.canonical "$REPLY"; # recurse unless root
    realpath.absolute "$REPLY" "$target";   # combine canon parent w/basename
}

realpath.relative() {
    local target=""
    realpath.absolute "$1"; set -- "$REPLY" "${@:2}"; realpath.absolute "${2-$PWD}" X
    while realpath.dirname "$REPLY"; [[ "$1" != "$REPLY" && "$1" == "${1#${REPLY%/}/}" ]]; do
        target=../$target
    done
    [[ $1 == "$REPLY" ]] && REPLY=${target%/} || REPLY="$target${1#${REPLY%/}/}"
    REPLY=${REPLY:-.}
}

# For documentation, see https://github.com/bashup/loco

set -euo pipefail

fn_exists() { declare -F -- "$1"; } >/dev/null
fn_copy()   { REPLY="$(declare -f $1)"; eval "$2 ${REPLY#$1}"; }
findup()    { walkup "${1:-$PWD}" reply_if_exists "${@:2}"; }

reply_if_exists() {
    local pat dir=$1 IFS= ; shift
    for pat; do
        for REPLY in ${dir%/}/$pat; do [[ -f "$REPLY" ]] && return 0; done
    done
    return 1
}

walkup() {
    realpath.absolute "$1"
    until set -- "$REPLY" "${@:2}"; "$2" "$1" "${@:3}"; do
        [[ "$1" != "/" ]] || return 1; realpath.dirname "$1"
    done
}

_loco_usage() { loco_error "Usage: $LOCO_COMMAND command args..."; }
_loco_error() { echo "$@" >&2; exit 64; }
_loco_cmd() { REPLY="$LOCO_NAME.$1"; }
_loco_exec() { loco_error "Unrecognized command: $1"; }
_loco_exists() { type -t "$1"; } >/dev/null

_loco_do() {
    [[ "${1-}" ]] || loco_usage   # No command given, exit w/usage
    REPLY=""; loco_cmd "$1"; local cmd="$REPLY"
    [[ "$cmd" ]] || loco_usage   # Unrecognized command, exit w/usage

    if loco_exists "$cmd"; then
        # Command, alias, function, or builtin exists
        shift; "$cmd" "$@"
    else
        # Invoke the default command interpreter
        loco_exec "$@"
    fi
}

_loco_findproject() {
    findup "$LOCO_PWD" "${LOCO_FILE[@]}" && LOCO_PROJECT=$REPLY ||
        loco_error "Can't find $LOCO_FILE here";
}
_loco_preconfig() { true; }
_loco_postconfig() { true; }
_loco_findroot() { realpath.dirname "$LOCO_PROJECT"; LOCO_ROOT=$REPLY; }
_loco_loadproject() { cd "$LOCO_ROOT";  $LOCO_LOAD "$1"; }
_loco_site_config() { source "$1"; }
_loco_user_config() { source "$1"; }


# Find our configuration, exposing relevant paths and defaults

_loco_config() {
    LOCO_ARGS=("$@")
    loco_preconfig "$@"
    ${LOCO_COMMAND:+:} realpath.basename "$LOCO_SCRIPT"; LOCO_COMMAND="${LOCO_COMMAND-$REPLY}"
    LOCO_NAME="${LOCO_NAME-${LOCO_COMMAND}}"
    LOCO_PWD="${LOCO_PWD-$PWD}"

    LOCO_SITE_CONFIG="${LOCO_SITE_CONFIG-/etc/$LOCO_NAME/config}"
    [ -f "$LOCO_SITE_CONFIG" ] && loco_site_config "$LOCO_SITE_CONFIG"
    LOCO_RC="${LOCO_RC-.${LOCO_NAME}rc}"
    LOCO_USER_CONFIG="${LOCO_USER_CONFIG-$HOME/$LOCO_RC}"
    [ -f "$LOCO_USER_CONFIG" ] && loco_user_config "$LOCO_USER_CONFIG"

    [[ ${LOCO_FILE-} ]] || LOCO_FILE=(".$LOCO_NAME")
    LOCO_LOAD="${LOCO_LOAD-source}"
    loco_postconfig "$@"
}

_loco_main() {
    loco_config "$@"
    fn_exists $LOCO_NAME || eval "$LOCO_NAME() { loco_do \"\$@\"; }"
    ${LOCO_PROJECT:+:} loco_findproject "$@"
    ${LOCO_ROOT:+:}    loco_findroot "$@"
    loco_loadproject "$LOCO_PROJECT"
    loco_do "$@"
}

# Initialize default function implementations
for f in $(compgen -A function _loco_); do
    fn_exists "${f#_}" || fn_copy "$f" "${f#_}"
done

# Clear all LOCO_*  variables before beginning
for lv in ${!LOCO_@}; do unset $lv; done

LOCO_SCRIPT=$0
loco_preconfig() {
    LOCO_FILE=("composer.json" "wp-cli.yml")
    LOCO_NAME=imposer
    LOCO_USER_CONFIG=$HOME/.config/imposer.md
    LOCO_SITE_CONFIG=/etc/imposer.md
}

loco_site_config() { run-markdown "$1"; }
loco_user_config() { run-markdown "$1"; }
loco_loadproject() { cd "$LOCO_ROOT"; }
imposer_dirs=()

get_imposer_dirs() {
    if [[ ${imposer_dirs[@]+_} ]]; then
        return
    elif (($#)); then
        true
    elif [[ ${IMPOSER_PATH-} ]]; then
        IFS=: eval 'set -- $IMPOSER_PATH'
    else
        set -- imposer "$(wp theme path)" "$(wp plugin path)" \
            "$( [[ -f composer.json ]] &&  composer config --absolute vendor-dir)" \
            "$(wp package path)" "$(composer global config --absolute vendor-dir)"
    fi
    imposer_dirs=()
    for REPLY; do
        if [[ "$REPLY" && -d "$REPLY" ]]; then
            [[ "$REPLY" == /* ]] || realpath.absolute "$REPLY"
            imposer_dirs+=("${REPLY%/}")
        fi
    done
} 2>/dev/null
imposer.path() {
    get_imposer_dirs;
    if [[ ${imposer_dirs[@]+_} ]]; then IFS=: eval 'echo "${imposer_dirs[*]}"'; fi
}

imposer.default-path() { local imposer_dirs=() IMPOSER_PATH=; imposer path; }
FILTER  jqmd::data\(\{\"options\":\[\]\,\"plugins\":\[\]\}\)
mdsh_raw_php+=($'$state = json_decode($args[0], true);\n\nforeach ( $state[\'options\'] as $opt => $new) {\n\t$old = get_option($opt);\n\tif (is_array($old) && is_array($new)) $new = array_replace_recursive($old, $new);\n\tif ($new !== $old) {\n\t\tif ($old === false) add_option($opt, $new); else update_option($opt, $new);\n\t}\n}\n\nif ( !empty( $plugins = $state[\'plugins\'] ) ) {\n\t$fetcher = new \\WP_CLI\\Fetchers\\Plugin;\n\t$plugin_files = array_column( $fetcher->get_many(array_keys($plugins)), \'file\', \'name\' );\n\t$activate = $deactivate = [];\n\tforeach ($plugins as $plugin => $desired) {\n\t\t$desired = ($desired !== false);\n\t\tif ( empty($plugin_files[$plugin]) ) {\n\t\t\tcontinue; # XXX warn plugin of that name isn\'t installed\n\t\t}\n\t\tif ( is_plugin_active($plugin_files[$plugin]) == $desired ) continue;\n\t\tif ( $desired ) {\n\t\t\t$activate[] = $plugin_files[$plugin];\n\t\t} else {\n\t\t\t$deactivate[] = $plugin_files[$plugin];\n\t\t}\n\t}\n\tdeactivate_plugins($deactivate);  # deactivate first, in case of conflicts\n\tactivate_plugins($activate);\n}\n')
imposed_states=
require() {
    get_imposer_dirs
    while (($#)); do
        if ! [[ $imposed_states == *"<$1>"* ]]; then
            imposed_states+="<$1>"
            if __find_state "$1"; then
                __load_state "$1" "$REPLY"
            else loco_error "Could not find state $1 in ${imposer_dirs[*]}"
            fi
        fi
        shift
    done
}
__find_state() {
    realpath.basename "$1"; local name=$REPLY
    realpath.dirname "$1"; local ns=$REPLY
    local patterns=("$1" "$1/default" "$1/imposer/default" "$ns/imposer/$name" )
    for REPLY in ${imposer_dirs[@]+"${imposer_dirs[@]}"}; do
        if reply_if_exists "$REPLY" "${patterns[@]/%/.state.md}"; then return; fi
    done
    false
}
__load_state() {
    if [[ ! "${IMPOSER_CACHE-_}" ]]; then
        run-markdown "$2"  # don't cache if IMPOSER_CACHE is an empty string
    else
        mdsh-cache "${IMPOSER_CACHE-$LOCO_ROOT/imposer/.cache}" "$2" "$1" unset -f mdsh:file-header mdsh:file-footer
        source "$REPLY"
    fi
}
cat-php() { printf '%s\n' '<?php' "${mdsh_raw_php[@]}"; }

imposer.require() {
    require "$@"
    if HAVE_FILTERS; then
        REPLY=$(RUN_JQ -c -n)
        CLEAR_FILTERS  # prevent auto-run to stdout
        cat-php | wp eval-file - "$REPLY"
    fi
}
imposer.json() { require "$@"; ! HAVE_FILTERS || RUN_JQ -n; }
imposer.php()  { mdsh_raw_php=(); require "$@"; CLEAR_FILTERS; cat-php; }
if [[ $0 == "${BASH_SOURCE-}" ]]; then loco_main "$@"; fi
